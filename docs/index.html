<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>bio_ik: bio-ik</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bio_ik
   </div>
   <div id="projectbrief">MoveIt kinematics_base plugin based on particle optimization &amp; GA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">bio-ik </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Disclaimer</h2>
<p>This repository provides a BSD-licensed standalone implementation of a variety of optimization methods to efficiently solve generalized inverse kinematics problems.</p>
<p>The whole module was implemented by Philipp Ruppel as part of his Master Thesis.</p>
<p>For a C++-based reimplementation of the original "BioIK" algorithm, as originally sold in the Unity store, you can use the non-default mode <code>bio1</code>. The default mode <code>bio2_memetic</code> shares no code with this implementation, was shown to outperform it in terms of success rate, precision and efficiency, and is actually usable for precise robotic applications [4].</p>
<h2>Installation and Setup</h2>
<p>You will need ROS version Indigo or newer (wiki.ros.org). The software was developed on Ubuntu Linux 16.04 LTS with ROS Kinetic, but has also been tested on Ubuntu Linux 14.04 LTS with ROS Indigo. Newer versions of ROS should work, but may need some adaptation. See below for version specific instructions.</p>
<ul>
<li>Download the <code>bio_ik</code> package and unpack into your catkin workspace.</li>
<li>Run <code>catkin_make</code> to compile your workspace: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;roscd</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd src</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;git clone https://github.com/TAMS-Group/bio_ik.git</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;roscd</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;catkin_make</div></div><!-- fragment --></li>
<li>Configure Moveit to use bio-ik as the kinematics solver (see next section).</li>
<li>Use Moveit to plan and execute motions or use your own code together with <code>move_group</code> node to move your robot.</li>
<li>As usual, the public API is specified in the public header files for the <code>bio_ik</code> package, located in the <code>include/bio_ik</code> subdirectory; the sources including a few private header files are in the <code>src</code> subdirectory.</li>
</ul>
<h2>Basic Usage</h2>
<p>For ease of use and compatibility with existing code, the bio-ik algorithm is encapsulated as a Moveit kinematics plugin. Therefore, bio-ik can be used as a direct replacement of the default Orocos/KDL-based IK solver. Given the name of an end-effector and a 6-DOF target pose, bio-ik will search a valid robot joint configuration that reaches the given target.</p>
<p>In our tests (see below), both in terms of success rate and solution time, bio-ik regularly outperformed the Orocos [1] solver and is competitive with trac-ik [2]. The bio-ik algorithm can also be used for high-DOF system like robot snakes, and it will automatically converge to the best approximate solutions for low-DOF arms where some target poses are not reachable exactly.</p>
<p>While you can write the Moveit configuration files by hand, the easiest way is to run the Moveit setup assistant for your robot, and then to select bio-ik as the IK solver when configuring the end effectors. Once configured, the solver can be called using the standard Moveit API or used interactively from rviz using the MotionPlanning GUI plugin.</p>
<ul>
<li>Make sure that you have a URDF (or xacro) model for your robot.</li>
<li>Run the moveit setup assistant to create the Moveit configuration files:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;rosrun moveit_setup_assistant moveit_setup_assistant</div></div><!-- fragment --><ul>
<li>The setup assistant automatically searches for all available IK solver plugins in your workspace. Therefore, you can just select select bio-ik as the IK solver from the drop-down list for every end effector and then configure the kinematics parameters, namely the default position accuracy (meters) and the timeout (in seconds). For typical 6-DOF or 7-DOF arms, an accuracy of 0.001 m (or smaller) and a timeout of 1 msec should be ok. More complex robots might need a longer timeout.</li>
<li>Generate the moveit configuration files from the setup assistant. Of course, you can also edit the <code>config/kinematics.yaml</code> configuration file with your favorite text editor. For example, a configuration for the PR2 robot might look like this:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# example kinematics.yaml for the PR2 robot</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;right_arm:</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  # kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  # kinematics_solver_attempts: 1</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  kinematics_solver: bio_ik/BioIKKinematicsPlugin</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  kinematics_solver_search_resolution: 0.005</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  kinematics_solver_timeout: 0.005</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  kinematics_solver_attempts: 1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;left_arm:</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  kinematics_solver: bio_ik/BioIKKinematicsPlugin</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  kinematics_solver_search_resolution: 0.005</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  kinematics_solver_timeout: 0.005</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  kinematics_solver_attempts: 1</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;all:</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  kinematics_solver: bio_ik/BioIKKinematicsPlugin</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  kinematics_solver_search_resolution: 0.005</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  kinematics_solver_timeout: 0.02</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  kinematics_solver_attempts: 1</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;# optional bio-ik configuration parameters</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;#  center_joints_weight: 1</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;#  minimal_displacement_weight: 1</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;#  avoid_joint_limits_weight: 1</div></div><!-- fragment --><ul>
<li><p class="startli">For a first test, run the Moveit-created demo launch. Once rviz is running, enable the motion planning plugin, then select one of the end effectors of you robot. Rviz should show an 6-D (position and orientation) interactive marker for the selected end-effector(s). Move the interactive marker and watch bio-ik calculating poses for your robot.</p>
<p class="startli">If you also installed the bio-ik demo (see below), you should be able to run one of the predefined demos: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;roslaunch pr2_bioik_moveit demo.launch</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;roslaunch pr2_bioik_moveit valve.launch</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;roslaunch pr2_bioik_moveit dance.launch</div></div><!-- fragment --></li>
<li>You are now ready to use bio-ik from your C/C++ and Python programs, using the standard Moveit API. To explicitly request an IK solution in C++: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;robot_model_loader::RobotModelLoader robot_model_loader(robot);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;auto robot_model = robot_model_loader.getModel();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;auto joint_model_group = robot_model-&gt;getJointModelGroup(group);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;auto tip_names = joint_model_group-&gt;getSolverInstance()-&gt;getTipFrames();</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;kinematics::KinematicsQueryOptions opts;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;opts.return_approximate_solution = true; // optional</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;robot_state::RobotState robot_state_ik(robot_model);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// traditional &quot;basic&quot; bio-ik usage. The end-effector goal poses</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// and end-effector link names are passed into the setFromIK()</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;// call. The KinematicsQueryOptions are empty.</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;//</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;bool ok = robot_state_ik.setFromIK(</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;            joint_model_group, // joints to be used for IK</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;            tip_transforms,    // multiple end-effector goal poses</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;            tip_names,         // names of the end-effector links</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;            attempts, timeout, // solver attempts and timeout</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;            moveit::core::GroupStateValidityCallbackFn(),</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;            opts               // mostly empty</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;          );</div></div><!-- fragment --></li>
</ul>
<h2>Advanced Usage</h2>
<p>For many robot applications, it is essential to specify more than just a single end-effector pose. Typical examples include</p>
<ul>
<li>redundancy resolution (e.g. 7-DOF arm)</li>
<li>two-arm manipulation tasks on two-arm robots (e.g. Baxter)</li>
<li>multi end-effector tasks with shared kinematic links</li>
<li>grasping and manipulation tasks with multi-finger hands</li>
<li>full-body motion on humanoid robots</li>
<li>reaching tasks with additional constraints (e.g. shoulder position)</li>
<li>incremental tool motions without robot arm configuration changes</li>
<li>and many more</li>
</ul>
<p>In bio-ik, such tasks are specified as a combination of multiple individual <em>goals</em>. The algorithm then tries to find a robot configuration that fulfills all given goals simultaneously by minimizing a quadratic error function built from the weighted individual goals. While the current Moveit API does not support multiple-goals tasks directly, it provides the KinematicQueryOptions class. Therefore, bio-ik simply provides a set of predefined motion goals, and a combination of the user-specified goals is passed via Moveit to the IK solver. No API changes are required in Moveit, but using the IK solver now consists passing the weighted goals via the KinematicQueryOptions. The predefined goals include:</p>
<ul>
<li><em>PoseGoal</em>: a full 6-DOF robot pose</li>
<li><em>PositionGoal</em>: a 3-DOF (x,y,z) position</li>
<li><em>OrientationGoal</em>: a 3-DOF orientation, encoded as a quaternion (qx,qy,qz,qw)</li>
<li><em>LookAtGoal</em>: a 3-DOF (x,y,z) position intended as a looking direction for a camera or robot head</li>
<li><em>JointGoal</em>: a set of joint angles, e.g. to specify a</li>
<li><em>FunctionGoal</em>: an arbitrary function of the robot joint values, e.g. to model underactuated joints or mimic joints</li>
<li>and several more</li>
</ul>
<p>To solve a motion problem on your robot, the trick now is to construct a suitable combination of individual goals.</p>
<div class="image">
<img src="doc/pr2_vt_0.png"  alt="PR2 turning a valve"/>
</div>
<p>In the following example, we want to grasp and then <em>slowly turn a valve wheel</em> with the left and right gripers of the PR2 robot:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;bio_ik::BioIKKinematicsQueryOptions ik_options;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;ik_options.replace = true;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;ik_options.return_approximate_solution = true;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;auto* ll_goal = new bio_ik::PoseGoal();</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;auto* lr_goal = new bio_ik::PoseGoal();</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;auto* rl_goal = new bio_ik::PoseGoal();</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;auto* rr_goal = new bio_ik::PoseGoal();</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;ll_goal-&gt;setLinkName(&quot;l_gripper_l_finger_tip_link&quot;);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;lr_goal-&gt;setLinkName(&quot;l_gripper_r_finger_tip_link&quot;);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;rl_goal-&gt;setLinkName(&quot;r_gripper_l_finger_tip_link&quot;);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;rr_goal-&gt;setLinkName(&quot;r_gripper_r_finger_tip_link&quot;);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;ik_options.goals.emplace_back(ll_goal);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;ik_options.goals.emplace_back(lr_goal);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;ik_options.goals.emplace_back(rl_goal);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;ik_options.goals.emplace_back(rr_goal);</div></div><!-- fragment --><p>We also set a couple of secondary goals. First, we want that the head of the PR2 looks at the center of the valve. Second, we want to avoid joint-limits on all joints, if possible. Third, we want that IK solutions are as close as possible to the previous joint configuration, meaning small and efficient motions. This is handled by adding the MinimalDisplacementGoal. Fourth, we want to avoid torso lift motions, which are very slow on the PR2. All of this is specified easily:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto* lookat_goal = new bio_ik::LookAtGoal();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;lookat_goal-&gt;setLinkName(&quot;sensor_mount_link&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;ik_options.goals.emplace_back(lookat_goal);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;auto* avoid_joint_limits_goal = new bio_ik::AvoidJointLimitsGoal();</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;ik_options.goals.emplace_back(avoid_joint_limits_goal);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;auto* minimal_displacement_goal = new bio_ik::MinimalDisplacementGoal();</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;ik_options.goals.emplace_back(minimal_displacement_goal);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;auto* torso_goal = new bio_ik::PositionGoal();</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;torso_goal-&gt;setLinkName(&quot;torso_lift_link&quot;);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;torso_goal-&gt;setWeight(1);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;torso_goal-&gt;setPosition(tf::Vector3( -0.05, 0, 1.0 ));</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;ik_options.goals.emplace_back(torso_goal);</div></div><!-- fragment --><p>For the actual turning motion, we calculate a set of required gripper poses in a loop: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;for(int i = 0; ; i++) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    tf::Vector3 center(0.7, 0, 1);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    double t = i * 0.1;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    double r = 0.1;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    double a = sin(t) * 1;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    double dx = fmin(0.0, cos(t) * -0.1);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    double dy = cos(a) * r;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    double dz = sin(a) * r;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    tf::Vector3 dl(dx, +dy, +dz);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    tf::Vector3 dr(dx, -dy, -dz);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    tf::Vector3 dg = tf::Vector3(0, cos(a), sin(a)) * (0.025 + fmin(0.025, fmax(0.0, cos(t) * 0.1)));</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    ll_goal-&gt;setPosition(center + dl + dg);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    lr_goal-&gt;setPosition(center + dl - dg);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    rl_goal-&gt;setPosition(center + dr + dg);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    rr_goal-&gt;setPosition(center + dr - dg);</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    double ro = 0;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    ll_goal-&gt;setOrientation(tf::Quaternion(tf::Vector3(1, 0, 0), a + ro));</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    lr_goal-&gt;setOrientation(tf::Quaternion(tf::Vector3(1, 0, 0), a + ro));</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    rl_goal-&gt;setOrientation(tf::Quaternion(tf::Vector3(1, 0, 0), a + ro));</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    rr_goal-&gt;setOrientation(tf::Quaternion(tf::Vector3(1, 0, 0), a + ro));</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    lookat_goal-&gt;setAxis(tf::Vector3(1, 0, 0));</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    lookat_goal-&gt;setTarget(rr_goal-&gt;getPosition());</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    // &quot;advanced&quot; bio-ik usage. The call parameters for the end-effector</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    // poses and end-effector link names are left empty; instead the</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    // requested goals and weights are passed via the ik_options object.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    //</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    robot_state.setFromIK(</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                  joint_model_group,           // active PR2 joints</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                  EigenSTL::vector_Affine3d(), // no explicit poses here</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                  std::vector&lt;std::string&gt;(),  // no end effector links here</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                  0, 0.0,                      // take values from YAML file</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                  moveit::core::GroupStateValidityCallbackFn(),</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                  ik_options       // four gripper goals and secondary goals</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                );</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    ... // check solution validity and actually move the robot</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div></div><!-- fragment --><p>When you execute the code, the PR2 will reach for the valve wheel and turn it. Every once in a while it can't reach the valve with its current arm configuration and will regrasp the wheel.</p>
<p>See [3] and [4] for more examples.</p>
<h2>Local vs. Global Optimization, Redundancy Resolution, Cartesian Jogging</h2>
<p>BioIK has been developed to efficiently find good solutions for non-convex inverse kinematics problems with multiple goals and local minima. However, for some applications, this can lead to unintuitive results. If there are multiple possible solutions to a given IK problem, and if the user has not explicitly specified which one to choose, a result may be selected randomly from the set of all valid solutions. When incrementally tracking a cartesian path, this can result in unwanted jumps, shaking, etc. To incrementally generate a smooth trajectory using BioIK, the desired behaviour should be specified explicitly, which can be done in two ways.</p>
<h4>Disabling Global Optimization</h4>
<p>BioIK offers a number of different solvers, including global optimizers and local optimizers. By default, BioIK uses a memetic global optimizer (<code>bio2_memetic</code>). A different solver class can be selected by setting the <code>mode</code> parameter in the <code>kinematics.yaml</code> file of your MoveIt robot configuration.</p>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;all:</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  kinematics_solver: bio_ik/BioIKKinematicsPlugin</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  kinematics_solver_search_resolution: 0.005</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  kinematics_solver_timeout: 0.02</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  kinematics_solver_attempts: 1</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  mode: gd_c</div></div><!-- fragment --><p>Currently available local optimizers: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gd, gd_2, gd_4, gd_8</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;gd_r, gd_r_2, gd_r_4, gd_r_8</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;gd_c, gd_c_2, gd_c_4, gd_c_8</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;jac, jac_2, jac_4, jac_8</div></div><!-- fragment --><p>Naming convention: <code>&lt;solver type&gt;_[&lt;variant&gt;_]&lt;number of threads&gt;</code></p>
<p>Notes:</p><ul>
<li>The <code>gd_*</code> solvers support arbitrary goal types.</li>
<li>The <code>jac_*</code> solvers only support pose goals but might in theory be more stable in some cases.</li>
<li>Relative performance depends on the application (it's probably best if you try it yourself for your particular robot and problem types).</li>
<li>During our tests, the <code>gd_c</code> variants usually outperformed the other local solvers.</li>
<li>For incremental tracking, a single-threaded variant without restarts is probably best suited (<code>gd_c</code>, <code>gd</code>, or <code>jac</code>).</li>
<li>You can also create different MoveIt move groups with different solver types. If you now want to plan a cartesian trajectory from end effector pose A to end effector pose B, you can use a move group with a global optimizer to find a matching initial pose for end effector pose A and a different move group with a local optimizer for incrementally generating a smooth cartesian trajectory from A to B.</li>
</ul>
<h4>Regularization</h4>
<p>You can force a global optimizer to return a local minimum through regularization.</p>
<ul>
<li>For the specific case of incremental robot motions (aka <em>jogging</em>), the simplest solution is to specify both a <em>PoseGoal</em> and the special <em>RegularizationGoal</em>, which tries to keep the joint-space IK solution as close as possible to the given robot seed configuration. Typically you would use a high weight for the <em>PoseGoal</em> and a smaller weight to the regularizer.</li>
<li>You can also add a <em>MinimalDisplacementGoal</em> instead of the <em>RegularizationGoal</em>. Both goals try to keep the IK solution close to the current/seed robot state, but differ slightly in the handling of fast and slow robot joints (e.g. the PR2 has fast arm joints and a rather slow torso lift joint). You might want to play with both goals to see which one better matches your needs.</li>
<li>Some industrial robot controllers on 7-DOF arms behave as if working on a 6-DOF arm with one extra joint. Typically, the value of the extra joint can be specified, and an IK solution is then searched for the remaining six joints. This behaviour can be achieved in bio-ik by combining a <em>PoseGoal</em> for the end-effector with a <em>JointPositionGoal</em> for one (any one) of the robot joints.</li>
<li>Another useful trick is trying to keep the robot joints centered, as this will allow robot (joint) motions in both directions. Just combine the <em>PoseGoal</em> with a <em>CenterJointsGoal</em>, and optionally also a <em>RegularizationGaol</em>.</li>
<li>You can also combine regularization with a local <code>gd_*</code> solver.</li>
</ul>
<h2>How it works</h2>
<p>The bio-ik solver is based on a memetic algorithm that combines gradient-based optimization with genetic and particle swarm optimization.</p>
<p>Internally, vectors of all robot joint values are used to encode different intermediate solutions (the <em>genotype</em> of the genetic algorithm). During the optimization, joint values are always checked against the active lower and upper joint limits, so that only valid robot configurations are generated.</p>
<p>To calculate the fitness of individuals, the cumulative error over all given individual goals is calculated. Any individual with zero error is an exact solution for the IK problem, while individuals with small error correspond to approximate solutions.</p>
<p>Individuals are sorted by their fitness, and gradient-based optimization is tried on the best few configuration, resulting in fast convergence and good performance for many problems. If no solution is found from the gradient-based optimization, new individuals are created by a set of mutation and recombination operators, resulting in good search-space exploration.</p>
<p>See [3] and [4] for more details. See [5] and [6] for an in-depth explanation of an earlier evolutionary algorithm for animating video game characters.</p>
<h2>Running the Self-Tests</h2>
<p>We have tested bio-ik on many different robot arms, both using the tranditional single end-effector API and the advanced multi end-effector API based on the KinematicsQueryOptions.</p>
<p>One simple selftest consists of generating random valid robot configurations, running forward kinematics to calculate the resulting end-effector pose, and the querying the IK plugin to find a suitable robot joint configuration. Success is then checked by running forrward kinematics again and checking that the end-effector pose for the generated IK solution matches the target pose. This approach can be run easily for thousands or millions of random poses, samples the full workspace of the robot, and allows to quickly generate success-rate and solution-time estimates for the selected IK solver.</p>
<p>Of course, running the tests requires installing the corresponding robot models and adds a lot of dependencies. Therefore, those tests are not included in the standard bio-ik package, but are packaged separately.</p>
<p>For convenience, we provide the <code>pr2_bioik_moveit</code> package, which also includes a few bio-ik demos for the PR2 service robot. These are kinematics only demos; but of course you can also try running the demos on the real robot (if you have one) or the Gazebo simulator (if you installed Gazebo).</p>
<p>Simply clone the PR2 description package (inside <code>pr2_common</code>) and the <code>pr2_bioik_moveit</code> package into your catkin workspace: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;roscd</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd src</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;git clone https://github.com/PR2/pr2_common.git</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;git clone https://github.com/TAMS-Group/bioik_pr2.git</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;catkin_make</div></div><!-- fragment --><p>For the FK-IK-FK performance test, please run</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;roslaunch pr2_bioik_moveit env_pr2.launch</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;roslaunch pr2_bioik_moveit test_fk_ik.launch</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;... // wait for test completion and results summary</div></div><!-- fragment --><h2>References</h2>
<ol type="1">
<li>Orocos Kinematics and Dynamics, <a href="http://www.orocos.org">http://www.orocos.org</a></li>
<li>P. Beeson and B. Ames, <em>TRAC-IK: An open-source library for improved solving of generic inverse kinematics</em>, Proceedings of the IEEE RAS Humanoids Conference, Seoul, Korea, November 2015.</li>
<li>Philipp Ruppel, Norman Hendrich, Sebastian Starke, Jianwei Zhang, <em>Cost Functions to Specify Full-Body Motion and Multi-Goal Manipulation Tasks</em>, IEEE International Conference on Robotics and Automation, (ICRA-2018), Brisbane, Australia. DOI: <a href="http://doi.org/10.1109/ICRA.2018.8460799">10.1109/ICRA.2018.8460799</a></li>
<li>Philipp Ruppel, <em>Performance optimization and implementation of evolutionary inverse kinematics in ROS</em>, MSc thesis, University of Hamburg, 2017 <a href="https://tams.informatik.uni-hamburg.de/publications/2017/MSc_Philipp_Ruppel.pdf">PDF</a></li>
<li>Sebastian Starke, Norman Hendrich, Jianwei Zhang, <em>A Memetic Evolutionary Algorithm for Real-Time Articulated Kinematic Motion</em>, IEEE Intl. Congress on Evolutionary Computation (CEC-2017), p.2437-2479, June 4-8, 2017, San Sebastian, Spain. DOI: <a href="http://doi.org/10.1109/CEC.2017.7969605">10.1109/CEC.2017.7969605</a></li>
<li>Sebastian Starke, Norman Hendrich, Dennis Krupke, Jianwei Zhang, <em>Multi-Objective Evolutionary Optimisation for Inverse Kinematics on Highly Articulated and Humanoid Robots</em>, IEEE Intl. Conference on Intelligent Robots and Systems (IROS-2017), September 24-28, 2017, Vancouver, Canada </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
